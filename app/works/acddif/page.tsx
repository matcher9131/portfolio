import { type Metadata } from "next";
import { pageProperties } from "./properties";
import CodeInline from "@/app/_components/code/codeInline";
import ExternalLink from "@/app/_components/externalLink";
import { siteTitle } from "@/app/_shared/const";
import ImgWithBasePath from "@/app/_shared/imgWithBasePath";

export const metadata: Metadata = {
    title: `${pageProperties.name} - ${siteTitle}`,
};

const AtCoderDifficulty = (): JSX.Element => {
    return (
        <article className="main-article">
            <h1>{pageProperties.name}</h1>
            <p>{pageProperties.description}</p>

            <h2>スクリーンショット</h2>
            <div className="w-2/3">
                <ImgWithBasePath
                    src="/works/acddif/screenshot.png"
                    alt="スクリーンショット"
                    srcSet={[
                        ["/works/acddif/screenshot-480.png", "480w"],
                        ["/works/acddif/screenshot.png", "1280w"],
                    ]}
                    sizes="66vw"
                />
            </div>

            <h2>リンク</h2>
            <iframe
                title="AtCoder Difficulty"
                src="https://hatenablog-parts.com/embed?url=https://matcher9131.github.io/atcoder-difficulty/"
                className="w-full max-w-screen-sm"
            ></iframe>

            <h2>Github</h2>
            <iframe
                title="matcher9131/atcoder-difficulty"
                src="https://hatenablog-parts.com/embed?url=https://github.com/matcher9131/atcoder-difficulty"
                className="w-full max-w-screen-sm"
            ></iframe>

            <h2>機能</h2>
            <ul>
                <li>
                    競技プログラミングコンテストサイト「<ExternalLink href="https://atcoder.jp/">AtCoder</ExternalLink>
                    」 の各種統計をグラフィカルに表示
                    <ul>
                        <li>各問題の推定難易度、および実際の参加者のレーティングによる正答率分布</li>
                        <li>各コンテストの参加者のレーティング分布</li>
                        <li>各コンテストにおける獲得点数とレーティングの対応表</li>
                    </ul>
                </li>
                <li>ユーザー名を入力することで推定難易度に加え推定正答率も表示できる</li>
            </ul>

            <h2>動作推奨環境</h2>
            <p>Google Chrome 最新版</p>

            <h2>使用技術</h2>
            <table className="table table-lg max-w-[600px]">
                <thead>
                    <tr>
                        <th>種別</th>
                        <th>名称</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>プログラミング言語</td>
                        <td>TypeScript</td>
                    </tr>
                    <tr>
                        <td>
                            プログラミング言語
                            <br />
                            （バッチスクリプト）
                        </td>
                        <td>Python</td>
                    </tr>
                    <tr>
                        <td>フロントエンドライブラリ</td>
                        <td>React</td>
                    </tr>
                    <tr>
                        <td>状態管理ライブラリ</td>
                        <td>Jotai</td>
                    </tr>
                    <tr>
                        <td>グラフライブラリ</td>
                        <td>Chart.js</td>
                    </tr>
                    <tr>
                        <td>CSSフレームワーク</td>
                        <td>Tailwind CSS</td>
                    </tr>
                    <tr>
                        <td>CSSフレームワーク</td>
                        <td>daisyUI</td>
                    </tr>
                    <tr>
                        <td>バックエンドサービス</td>
                        <td>Supabase</td>
                    </tr>
                    <tr>
                        <td>ビルドツール</td>
                        <td>Vite</td>
                    </tr>
                    <tr>
                        <td>リンター</td>
                        <td>ESLint</td>
                    </tr>
                    <tr>
                        <td>テストツール</td>
                        <td>Vitest</td>
                    </tr>
                    <tr>
                        <td>テストライブラリ</td>
                        <td>React Testing Library</td>
                    </tr>
                    <tr>
                        <td>CI/CD</td>
                        <td>GitHub Actions</td>
                    </tr>
                    <tr>
                        <td>生成AI</td>
                        <td>
                            Claude Code
                            <br />
                            ※主にテストコード作成に使用
                        </td>
                    </tr>
                </tbody>
            </table>

            <h2>このサイトを作ったきっかけ</h2>
            <p>
                AtCoderの問題復習支援サイトといえば
                <ExternalLink href="https://recoiljs.org/docs/guides/testing">AtCoder Problems</ExternalLink>
                があるが、2025年に入ってからこのサイトにおける各問題の推定難易度表示の更新が（長ければ1か月以上も）止まることがあり、自分が解けた
                or 解けなかった問題がどの程度の難易度だったのかを知ることが難しくなってしまった。
            </p>
            <p>
                しかしAtCoderにおいて各コンテスト参加者のレーティングと問題が解けたかどうかのデータは公開されており、さらに問題の難易度推定は
                <ExternalLink href="https://ja.wikipedia.org/wiki/%E9%A0%85%E7%9B%AE%E5%BF%9C%E7%AD%94%E7%90%86%E8%AB%96">
                    IRT（項目応答理論）
                </ExternalLink>
                でできることを知っていたので、「ついでにPythonの習得も兼ねて自分でやってみるのもアリなのではないか」と思い立つに至った。
            </p>

            <h2>使用技術の選定理由</h2>
            <h3>SPAかMPAか</h3>
            <p>
                表示するものは文字列・数値のみでグラフィック等がないため、一度にそれなりの量を読み込んでも時間がかからない。
                それならばページ遷移のたびに多少なりとも待ち時間が発生するMPAはメリットが薄いと判断し、SPAを採用した。
            </p>

            <h3>プログラミング言語およびフロントエンドライブラリ</h3>
            <p>SPAなのでいつものTypeScript + Reactの構成を選択した。</p>

            <h3>バッチスクリプトのプログラミング言語</h3>
            <p>
                統計処理が必要になるのでPythonとRを検討し、自身のスキルとしてより役立ちそうなPythonを選択した。（統計処理とはいっても高度に複雑なことをやるわけではないので、
                最悪<CodeInline>numpy</CodeInline>と<CodeInline>scipy.optimize</CodeInline>
                さえあれば大丈夫やろ！の精神で）
            </p>

            <h3>状態管理ライブラリ</h3>
            <p>
                これまでRecoilを使っていたがメンテナンスの将来性がどうも怪しくなってきたので、これを機にJotaiを使ってみることにした。
            </p>

            <h3>ビルドツール</h3>
            <p>Viteで困ったことがないためいつも通りViteで。</p>

            <h2>開発時に苦労した点・工夫した点</h2>
            <h3>AtCoderのレーティングシステムに起因する難易度推定の際に考慮すべき事項</h3>
            <p className="py-1.5">
                AtCoderのレーティングシステムは
                <ExternalLink href="https://www.dropbox.com/scl/fi/2jbios4dut90lqszooqxi/rating.pdf?rlkey=37ihxdai8nfcm51l9ekhv3z4d&e=1&dl=0">
                    公開されている資料
                </ExternalLink>
                にあるとおり、パフォーマンス値を用いた計算による値（以降、これを<strong>生レーティング</strong>
                と呼ぶ）から「参加回数による補正値」を引くという構図になっている。
            </p>
            <p className="py-1.5">
                ここでこの「参加回数による補正値」がかなりの厄介者となる。というのもリセマラ防止の側面もあるためかかなり巨大なものとなっており、
                具体的には10回参加したユーザーでも150程度、極端な例だと1回のみ参加したユーザーでは1200にもなる。
            </p>
            <p className="py-1.5">
                問題の難易度を推定する際においては、その問題が解かれるかどうかは各ユーザーの
                <strong>生レーティング</strong>
                にのみ相関がある、としたいわけで、これほどの巨大な補正（しかもユーザーの実力に関係がない！）があると推定結果が大いに歪むことが想定される。
            </p>
            <p className="py-1.5">
                例えば参加回数がある一定水準（例えば20回程度）に満たないユーザーを無視して難易度推定を行うという手法もあるが、参加回数と実力には強い正の相関があるため
                <sup>[要出典]</sup>
                特に低難易度帯において対象となるユーザーの正答率が本来より高くなってしまう可能性が高い。
            </p>
            <p className="py-1.5">
                よって各ユーザーのコンテスト参加回数を取得し、<strong>生レーティング</strong>
                を逆算して各問題の難易度推定を行おうとしたが、ここで問題が発生する。
            </p>

            <h3>過去コンテストにおける情報の相違</h3>
            <p className="py-1.5">
                AtCoderではいくつかのデータがJSON形式でも公開されており、各コンテストの順位表もそれにあたる。
                そしてそのJSONには各ユーザーのコンテスト参加回数が記載されているので、これをそのまま使えばよいと思いきや、この値は
                <strong>JSONにアクセスした日時におけるもの</strong>
                であり、ユーザーが該当するコンテストに参加した時点のものではない。
                よって最新のコンテストならともかく、昔のコンテストを遡って難易度推定を行おうとするとこの値は使えない。
            </p>
            <p className="py-1.5">
                ただ情報サイトを作る以上、過去のものを掲載しないというのはイマイチすぎる。よって各ユーザーページを個別に見ることでなんとか対応することにした。
                アクセスするページ数が膨大に跳ね上がるが、十分に間隔を取ってAtCoderのサイトに負担がかからないように配慮した。
            </p>
            <p className="py-1.5">
                （なお前述の通り新しいコンテストのものを取得する際にはこの問題は発生しないため、後述するCI/CDを行う際にはすべてのユーザーページを見ているわけではない）
            </p>

            <h3>CI/CD</h3>
            <p className="py-1.5">
                このアプリを作ったきっかけの項でも触れたが、本サイトは各問題の推定難易度を比較的速やかに提供するのが目的であるため、継続的な更新が必要となる。
            </p>
            <p className="py-1.5">
                しかし手動で更新を行うと必ず抜け・漏れが発生するのが人の性である。せっかくなので最新コンテストのデータ取得から各統計処理、サイト更新までを自動で行えるようにGitHub
                ActionsでPythonスクリプトを実行するようにした。
                現状コンテストは土日の21:00(JST)から始まることがほとんどなので、AtCoder側のレーティング更新にかかる時間も考えて実行時間を土日の24:00(JST)に設定している。
            </p>

            <h3>AtCoder Problemsとの差別化</h3>
            <p className="py-1.5">
                いくら速報性が比較的高いとはいえ、単に各問題の推定難易度を載せるだけなら単なる二番煎じに過ぎず、かつあちらのほうが多機能である。そこで2つの機能で差別化を図った。
            </p>

            <h4>厳密な難易度推定</h4>
            <p className="py-1.5">
                難易度推定にはAtCoder
                Problemsでも本サイトでもIRT（2パラメータロジスティックモデル、以下2PL）を用いている。2PLでは以下の2つのパラメータで問題の難易度を記述する。
            </p>
            <ul>
                <li>困難度: 問題の難しさを示す数値であり、正答率が50%になるようなレーティングを表す。</li>
                <li>
                    識別力:
                    高いほど高レーティング者の正答率が高く＆低レーティング者の正答率が低くなる。低いほど高レーティング者でも間違う代わりに低レーティング者でも正解できる余地がある。
                </li>
            </ul>
            <p className="py-1.5">
                AtCoder
                Problemsでは計算量削減のためか識別力を一定の値に固定して計算しているため、Recommendedで表示される各問題の推定正答率は問題の困難度にのみ依存している。
                すなわち、「低レーティング者でも正解できる余地のある問題」などが埋もれてしまう。ここに差別化の余地があるとみて、本サイトでは識別力も計算することにした。
            </p>
            <p className="py-1.5">
                ただしIRTによる推定を行えるPythonライブラリをいくつか探してみたが、
                各受験者の能力値（レーティング）と正答したかどうかのみを与えて問題の識別力と困難度を得られるものがどうにも見つからなかった（探すのが下手なだけかもしれないが……）ため、
                <CodeInline>scipy.optimize.minimize</CodeInline>を用いて最小二乗法で識別力と困難度を求めることに。
            </p>
            <p className="py-1.5">
                使用するモデルや食わせるデータを色々試行錯誤した結果、モデルは<CodeInline>Nelder-Mead</CodeInline>
                、食わせる能力値は<CodeInline>(x - x0) / 600</CodeInline>（<CodeInline>x0</CodeInline>
                は全参加者の平均レーティング）とするのが最も収束しやすいようであることがわかり、それを採用した。
            </p>

            <h4>コンテストに対する統計</h4>
            <p className="py-1.5">
                例えばpaizaのような1問を解く毎にレーティングが変動するようなサービスとは異なり、AtCoderはコンテストの中でどの問題をどれだけ素早く解くのかによってレーティングが変化する。
                よって1問ごとの難易度も勿論重要なのだが、1つのコンテスト内で問題を横断する情報も同様あるいはそれ以上の価値を持つ。
                AtCoder Problemsはコンテストの統計情報を載せていないため、ここも差別化の余地になるとみた。
            </p>
            <p className="py-1.5">
                具体的には各コンテストにおけるスコア・順位とレーティング（正しくはパフォーマンス）の対応表を作ることにした。以下の2点ともが気になるポイントになると考え、2つとも実装した。
            </p>
            <ul>
                <li>
                    どの問題を正解すれば最低どの程度のパフォーマンスになるのか
                    <ul>
                        <li>
                            コンテスト内の問題数を<CodeInline>N</CodeInline>として正解・不正解の全組み合わせ
                            <CodeInline>2^N</CodeInline>
                            通りのそれぞれにおいて最も時間がかかったユーザーのパフォーマンスを記録する。該当する参加者が存在しない場合はスキップ。
                        </li>
                    </ul>
                </li>
                <li>
                    あるパフォーマンスを得るにはどの問題をどれくらいの時間で正解する必要があるのか
                    <ul>
                        <li>
                            ユーザー名の色が変化する400の倍数のパフォーマンスを対象に、該当するパフォーマンスを取得したユーザーが存在すればそのスコアと時間を記録する。
                            存在しない場合はその前後のユーザーから推定されるスコアと時間を記録する。
                        </li>
                    </ul>
                </li>
            </ul>
            <p className="py-1.5">
                しれっとユーザーのパフォーマンスを取得するように書いているが、コンテストのJSONデータには各プレイヤーが得たパフォーマンスが記載されているわけではない。
                そのためこれもユーザーページにアクセスして情報を得る必要がある。
                勿論全参加ユーザーを見るのは非効率なので二分探索を用いているのだが、稀にユーザーが削除されている場合があるため「降順に並んでいるもののアクセスするまで値が
                <CodeInline>None</CodeInline>
                かどうかがわからない配列に対する二分探索」という謎のアルゴリズムを組む羽目になった。
            </p>

            <h3>バックエンド</h3>
            <p className="py-1.5">
                問題の難易度は定数のため常に表示できるが、その問題をどの程度の確率で解けるのかは生レーティングがわからないと表示できない。
                よってレーティングと参加回数を入力すれば推定正答率が表示されるようにしたのだが、レーティングはともかく参加回数まで調べて入力するのはユーザビリティの面で非常に微妙である。
            </p>
            <p className="py-1.5">
                どうせならユーザー名を入れるだけで自動で情報を取得して生レーティングを計算できるようにしたい。
            </p>
            <p className="py-1.5">
                しかしブラウザからAtCoderのユーザーページを取得するリクエストを投げるとCORS制限に引っかかってしまい情報が取得できない。
                よってバックエンドを用意することにした。
            </p>
            <p className="py-1.5">
                ユーザー名を受け取って対応するユーザーページにアクセスしてレーティングと参加回数を返す関数だけを実装すればいいのだが、念の為一旦DBに保存して以降はDBから返すようにしている。
                勿論コンテストがあると更新される可能性が高いので、CI/CDと同様に土日24:00(JST)を超えてアクセスがあった場合はユーザーページから取得し直すようにした。
            </p>

            <h3>ページネーション</h3>
            <h4>ページ数が多い場合</h4>
            <p className="py-1.5">
                特に問題を一覧表示するタブにおいてページ数が膨大な数になるため、よく見るページネーション（先頭と最終ページおよび現在の前後2,3ページを表示する）では操作性が悪い。
            </p>
            <p>ここではAtCoderの順位表のページを参考にして、2の累乗を用いたページネーションにすることにした。</p>

            <h4>0を基準とする</h4>
            <p className="py-1.5">
                問題を一覧表示するタブでは推定正答率の昇順で表示しているが、これが50%となる問題が含まれるページの番号が0になるように番号を振っている。
                素直に先頭ページの番号を1にするのに比べて基準となるページの番号を覚えずに済むというメリットがある。
                勿論ページネーションでも常に0を表示することですぐに基準となるページに戻れるようにしている。
            </p>

            <h3>データ量の削減・遅延読み込み</h3>
            <p className="py-1.5">
                データがコンテスト名・問題名・問題の推定難易度のみなら大したサイズにならないが、グラフ表示のためのデータを持たせるとなると少々話が変わってくる。
                いくら令和のこのご時世とはいえ、無駄にサイズのデカいJSONを投げつけると応答速度が落ちてイケてないサイトになってしまう。そこで以下に挙げる対策を施した。
            </p>

            <h4>正答率データの圧縮</h4>
            <p className="py-1.5">
                各問題のレーティング別正答率をグラフで表示する機能のために、レーティング幅25ごとの正答率を記したデータを渡す必要がある。
                ただしJSONで小数からなる配列をそのまま垂れ流すとひどいサイズになるため、
            </p>
            <ul>
                <li>まずパーセント表記で整数になるように値を丸め、</li>
                <li>
                    Uint8Arrayと見てBase64でエンコードする（Base64自体はサイズが増えるが、Uint8Arrayをそのまま文字列化したものと比べれば短い）
                </li>
            </ul>
            <p className="py-1.5">という手法で圧縮を図った。</p>
            <p className="py-1.5">
                （なお小数のままバイナリにすることも考えたが、TypeScript側でバイナリを浮動小数点型として読む良い方法が見つからなかったため却下した。）
            </p>

            <h4>コンテスト参加者データの圧縮</h4>
            <p className="py-1.5">
                各コンテストについてもレーティング幅25ごとの参加人数をグラフで表示するためのデータが必要となる。
                こちらは整数のためそのままBase64でエンコードしてもよいのだが、（RatedとUnratedの2種に分けたとしても）255を超える数値が存在するためにUint8Arrayとして見ることはできない。
            </p>
            <p className="py-1.5">
                しかし最も参加者が多いABCでも現状1万人程度であるため（しかもそのすべてが1つのレーティング幅に収まるわけがないので）、Uint16ArrayとしてBase64でエンコードすることはできる。
                ただし2バイトが必要になる数値の個数はそう多くないことから、元のバイト列を考えるとかなりの数の0が存在することになり、まだ圧縮できそうである。
            </p>
            <p className="py-1.5">
                とはいえ本格的な圧縮アルゴリズムを使うとなると、「Pythonで圧縮・シリアライズ」→「TypeScriptでデシリアライズ・解凍」という運用の都合上しっくりくるものが無い。
            </p>
            <p className="py-1.5">
                なので最終的に Microsoft
                Copilotなどの助けも借りつつ、「各バイトが0かどうかのフラグを並べたビット列」「0であるバイトを削除して詰めたバイト列」の2つをそれぞれBase64でエンコードすることにした。
            </p>

            <h4>チャンク化</h4>
            <p>
                以上の圧縮を行っても、すべての問題やコンテストのデータを一度に持とうとするとやはりサイズが大きすぎる。
                ただし、一覧表示で一度に複数のデータを表示する必要のある項目（コンテスト名、問題名、問題の推定難易度）とは異なり、グラフ用のデータは一度に複数を要求することはない。
                よってコンテスト毎、問題毎にファイルを分けて遅延読み込みさせてもよいのだが、その場合異なるコンテスト・問題の統計表示画面にアクセスするたびに待ち時間が生じるためユーザーフレンドリーではない。
                そのため遅延読み込みなのはそのままに、いくつかのチャンクに分けることで読み込みによる待ち時間の回数と長さのバランスを取った。
            </p>
        </article>
    );
};

export default AtCoderDifficulty;
