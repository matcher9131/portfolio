import { type Metadata } from "next";
import ColumnHeader from "./_code/columnHeader";
import LazySearch from "./_code/lazySearch";
import { pageProperties } from "./properties";
import CodeInline from "@/app/_components/code/codeInline";
import ExternalLink from "@/app/_components/externalLink";
import { siteTitle } from "@/app/_shared/const";

export const metadata: Metadata = {
    title: `${pageProperties.name} - ${siteTitle}`,
};

const KanColleQuestManager = (): JSX.Element => {
    return (
        <article className="main-article">
            <h1>{pageProperties.name}</h1>
            <p>{pageProperties.description}</p>

            {/* ここにスクリーンショット */}

            <h2>リンク</h2>
            <iframe
                title="艦これ任務リストマネージャー"
                src="https://hatenablog-parts.com/embed?url=https://kc-quest.net/"
                className="w-full max-w-screen-sm"
            ></iframe>

            <h2>機能</h2>
            <ul>
                <li>
                    任務進捗管理機能
                    <ul>
                        <li>任務達成状況を手動で切り替え、その状況をLocalStorageに自動的に保存</li>
                        <li>
                            高性能な検索機能
                            <ul>
                                <li>
                                    報酬としてもらえるゲーム内アイテムをキーに検索できるのは勿論のこと、ゲーム内では明かされない前提任務（ある任務を出現させるためにクリアする必要のある任務）や後続任務（ある任務をクリアすることで出現する新たな任務）を再帰的に検索可能
                                </li>
                            </ul>
                        </li>
                        <li>非公式Wikiの内容をスクレイピングし、半自動的にデータを更新</li>
                        <li>
                            その他の機能は
                            <ExternalLink href="https://kc-quest.net/help">
                                艦これ任務リストマネージャー ヘルプ
                            </ExternalLink>
                            を参照ください
                        </li>
                    </ul>
                </li>
                <li>
                    遠征の成否・報酬計算機能
                    <ul>
                        <li>
                            入力された艦隊のデータ（艦娘および装備）に応じて、遠征の成否および獲得報酬量を表形式で一覧表示
                            <ul>
                                <li>艦娘・装備のステータスは自動計算されるため入力が不要</li>
                            </ul>
                        </li>
                        <li>報酬アイテムをキーにした検索が可能</li>
                        <li>
                            その他の機能は
                            <ExternalLink href="https://kc-quest.net/expeditions/help/">
                                遠征チェッカーヘルプ - 艦これ任務リストマネージャー
                            </ExternalLink>
                            を参照ください
                        </li>
                    </ul>
                </li>
            </ul>

            <h2>動作推奨環境</h2>
            <ul>
                <li>端末：PC、スマホ</li>
                <li>ブラウザ：Google Chrome, Microsoft Edge, Firefox 各最新版</li>
            </ul>

            <h2>使用技術</h2>
            <table className="table table-lg max-w-[400px]">
                <thead>
                    <tr>
                        <th>種別</th>
                        <th>名称</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>プログラミング言語</td>
                        <td>TypeScript</td>
                    </tr>
                    <tr>
                        <td>フロントエンドライブラリ</td>
                        <td>React</td>
                    </tr>
                    <tr>
                        <td>状態管理ライブラリ</td>
                        <td>Recoil</td>
                    </tr>
                    <tr>
                        <td>CSSフレームワーク</td>
                        <td>Tailwind CSS</td>
                    </tr>
                    <tr>
                        <td>CSSフレームワーク</td>
                        <td>daisyUI</td>
                    </tr>
                    <tr>
                        <td>ビルドツール</td>
                        <td>Vite</td>
                    </tr>
                    <tr>
                        <td>リンター</td>
                        <td>ESLint</td>
                    </tr>
                    <tr>
                        <td>テストツール</td>
                        <td>Vitest</td>
                    </tr>
                    <tr>
                        <td>テストライブラリ</td>
                        <td>React Testing Library</td>
                    </tr>
                </tbody>
            </table>

            <h2>このアプリを作ったきっかけ</h2>
            <p>
                「艦隊これくしょん
                -艦これ-」（以下、艦これと表記）は基本的にプレイヤーに情報をほとんど与えず、プレイヤー間の検証の積み重ねでようやくゲームシステムがわかるようなデザインがなされている。
                <br />
                これは達成することで様々なアイテムを入手できる「任務」も例外ではなく、基本的には前提となる任務を達成することで次の任務がアンロックされる形式ではあるものの、そもそもその前提となる任務が一切わからないどころか、報酬アイテムまでもがわからない。
                <br />
                ありがたいことに有志プレイヤーによって非公式Wikiにその辺の情報がまとめられるのだが、Wikiとにらめっこしても解消しない問題がさらに存在する。
                <br />
                それは「クリア済みの任務が表示されなくなる」というUIデザインにより、クリアしたことで表示されていないのか、まだ出現条件を満たしていないため表示されていないのかが判断できないことである。
                <br />
                よって「任務」、「獲得できるアイテム」、「出現させるためにクリアする必要のある任務」の3つが同時に表示できて、かつ任務達成状況を保存できるWebアプリを自分で作ってしまえばよいのではないかと考えた。
            </p>

            <h2>使用技術の選定理由</h2>
            <h3>Webアプリかクライアントアプリか</h3>
            <ul>
                <li>任務は定期的に新しいものが追加されるため、定期的にアップデートする必要がある</li>
                <li>なるべく多くの端末で動かせるようにしたい</li>
            </ul>
            <p>以上の2点より、Webアプリを選択した。</p>

            <h3>情報の保存場所</h3>
            <p>
                ユーザーにログインの手間をかけてまでサーバー側に保存するべきものでもないと判断した。
                <br />
                個人を特定できる情報が含まれるわけではないので、Local
                Storageなら半永久的に保存できるので問題ない。と思っていたら…
                <br />
                <b>Safariは7日間アクセスがないと消える</b>…だと…？
                <br />
                <s>
                    そんなつまらん制限かけてる間に他のブラウザにとっくに実装されているCSS周りの機能を早く実装しろ！これだからAppleは…
                </s>
                <br />
                これは調べてももう代替手段が無いようなので、Safariは動作保証対象外としてLocal
                Storageを使用することにした。
            </p>

            <h3>プログラミング言語</h3>
            <p>
                Local Storageを使うことで全てフロントエンド側で動作させられるので、JavaScriptまたはAlt
                JSを候補に検討する。
                <br />
                ある程度の規模になるため、型システムが強力かつ私自身の知見があるTypeScriptに決定。
            </p>

            <h3>フロントエンドライブラリ</h3>
            <p>最終的に最も慣れ親しんでいるReactを採用したが、以下も検討した。</p>
            <h4>Vue 3</h4>
            <p>
                経験はあるしライブラリの選定にあまり時間をかけなくてよいメリットはあるが、<CodeInline>ref</CodeInline>や
                <CodeInline>reactive</CodeInline>周りが直感的でなく煩わしい（<CodeInline>.value</CodeInline>
                があったりなかったり）ので却下。
            </p>

            <h4>SolidJS</h4>
            <p>
                Reactに書き味が似ていてさらにHooksのルールが無く、かつ軽量な動作ということでかなり魅力的ではあるが、使った経験が無いうえに分割代入に難があるので今回は見送り。（後者に関してはリンターで縛ることはできるが）
            </p>

            <h3>状態管理ライブラリ</h3>
            <ul>
                <li>
                    ライブラリを使わない
                    <ul>
                        <li>
                            <CodeInline>props</CodeInline>バケツリレー
                            <ul>
                                <li>
                                    <span className="line-through">流石に面倒くさすぎる</span>
                                </li>
                                <li>Presentationのためのpropsと状態管理のためのpropsが混ざるのは保守面でも良くない</li>
                            </ul>
                        </li>
                        <li>
                            <CodeInline>useContext</CodeInline>
                            <ul>
                                <li>
                                    <ExternalLink href="https://zenn.dev/kazuma1989/articles/68c2339e056530">
                                        ぼくのかんがえたさいきょうの useState + useContext よりも Redux
                                        のほうが大抵勝っている
                                    </ExternalLink>
                                    を読んで、これもないと判断
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    Redux
                    <ul>
                        <li>
                            昔からあるメジャーな状態管理ライブラリ
                            <ul>
                                <li>古くからあるためいわゆる「枯れた技術」</li>
                            </ul>
                        </li>
                        <li>お決まりの作法があり、書き方がブレない</li>
                        <li>
                            ただしそのお決まりの作法のせいで簡単な状態操作を書くだけでもシンプルにできない
                            <ul>
                                <li>
                                    Action毎に<CodeInline>type</CodeInline>を割り振って引数などを
                                    <CodeInline>payload</CodeInline>に設定し
                                </li>
                                <li>
                                    ReducerではActionの<CodeInline>type</CodeInline>を<CodeInline>switch文</CodeInline>
                                    などで分岐させて状態操作の実装を書き
                                </li>
                                <li>
                                    そしてコンポーネントでActionを作って<CodeInline>dispatch</CodeInline>する
                                </li>
                            </ul>
                        </li>
                        <li>何度か使ったことはあるが、ボイラープレート感が半端ではなかったため却下</li>
                    </ul>
                </li>
                <li>
                    Recoil
                    <ul>
                        <li>
                            シンプルであり（Reduxと比べて）書き方が強制されない
                            <ul>
                                <li>
                                    これに関してはデメリットでもあるので、以下のページを参考にして書き方を統一している
                                    <br />
                                    <ExternalLink href="https://zenn.dev/warabi/articles/2521222d57a71f">
                                        秩序あるRecoilの使い方を考える
                                    </ExternalLink>
                                    <br />
                                    （少々ボイラープレート感はあるがReduxよりはマシということで）
                                </li>
                            </ul>
                        </li>
                        <li>
                            <CodeInline>Atom</CodeInline>や<CodeInline>Selector</CodeInline>
                            で同期・非同期の差を吸収させられる
                            <ul>
                                <li>
                                    Reactの<CodeInline>Suspense</CodeInline>との親和性が高い
                                </li>
                            </ul>
                        </li>
                        <li>
                            まだメジャーバージョンが0番台のまま
                            <ul>
                                <li>これに関しては何度か使用した経験から特に大きな問題は見られないため良しとした</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    Jotai
                    <ul>
                        <li>
                            Recoilよりもシンプルに書ける
                            <ul>
                                <li>一方で込み入ったことをしようとするとシンプルではなくなる？</li>
                            </ul>
                        </li>
                        <li>Recoilに比べてはっきり優位な点が見出せなかったので今回は見送り</li>
                    </ul>
                </li>
            </ul>

            <h3>ビルドツール</h3>
            <p>
                Viteを使い出してからSPAはこれ一択になってしまった…。とにかく速い！そして設定が（比較的）わかりやすい！
                <s>設定に関してはViteがわかりやすいというよりはWebpackがクソわかりにくいだけとも言える</s>
                <br />
                何となくVite + Vueで語られることが多い<sup>[要検証]</sup>がVite +
                Reactでも何の問題もないし、しかもビルドオプションで複数ページの出力も（多少アセットの切り分け方に躓いたものの）難なくできるので強すぎる。
            </p>

            <h2>開発時に苦労した点・工夫した点</h2>
            <h3>検索性</h3>
            <p>本アプリのコンセプト的に、以下に対する検索機能を付けたい。</p>
            <ul>
                <li>任務名称</li>
                <li>任務達成でもらえるアイテム</li>
                <li>
                    前提任務（その任務を出現させるためにクリアすべき任務）や後続任務（その任務をクリアすることが出現のフラグになっている任務）
                </li>
            </ul>
            <p>
                任務名称と任務達成でもらえるアイテムの検索はテキストによるものなので、テキストボックスは必要。あとは前提任務・後続任務をどうするかだが、これもテキストボックスを使うこととした。
                <br />
                具体的にはプレフィクスを設け、それに続けて任務IDを入力することで対応した。例えば「p:A100」なら任務IDがA100の任務の前提任務をすべて表示する、といった具合である。
                ただしプレフィクスを覚えて入力することを強制するのはユーザビリティが良くないので、各任務にボタンを割り当て、押せば自動的にテキストボックスに「p:A100」などと入力されるようにした。
                <br />
                これにより検索機能がすべてテキストボックスに集約されたので、Model側のロジックがすっきりできて良し。
            </p>

            <h3>前提任務・後続任務</h3>
            <p>
                先ほどから何度も話題に上がっている前提任務だが、2種類の検索を用意した。文字通り出現のフラグになっている任務を表示する「p:」プレフィクスと、その任務を出現させるためにクリアするべき全ての任務を表示する「a:」プレフィクスである。
                <br />
                後者に関してはデータを保持しているわけではなく、任務群を有向グラフと見立ててDFS（深さ優先探索）で探索をしている。DFSは再帰呼び出しで実装することが多いが、RecoilのSelectorで探索部を実装しておりSelectorの再帰呼び出しのオーバーヘッドがどれくらいのものかわからなかったので、
                <CodeInline>Array</CodeInline>
                をスタックに見立てて実装した。このあたり、AtCoderなどの競技プログラミングを触っていた経験が生きている。
                <br />
                ここまで前提任務について述べたが、後続任務に関しても全く同じである。（グラフの辺の向きを入れ替えただけ）
            </p>

            <h3>履歴</h3>
            <p>
                実際に自分で使ってみるとワンクリックで前の画面に戻りたい…となることが多かったのでHistory
                APIを用いて「戻る」「進む」を実装することにした。具体的には以下の通り。
                <ul>
                    <li>
                        任務IDボタンが押される、検索テキストが変化する、フィルターボタンが押されることによって表示する任務が変化するとき、いくつかのAtomの内容を1つのオブジェクトにまとめて
                        <CodeInline>pushState</CodeInline>する
                    </li>
                    <li>
                        各Atomの内容を履歴の内容に置き換えるメソッドを<CodeInline>popstate</CodeInline>
                        イベントにセットする
                    </li>
                </ul>
                実のところページ遷移も履歴に入れたかったが、検索内容が変化したときにページ番号を1に戻す仕様とバッティングしてうまく同期が取れなかったので諦めることに…。
            </p>

            <h3>負荷軽減</h3>
            <p>
                検索機能をテキストボックスの値に結び付けた影響でキー入力のたびに検索が走って重くなったため、以下の対策を施した。
            </p>

            <h4>ページネーション</h4>
            <p>
                一度に表示する任務の量を少なくすれば勿論負荷軽減になるので、ページネーションを施した。
                <br />
                1ページあたりの表示件数は性能の低い端末を考えれば少ないほうがいいが、せっかく性能の高い端末を使っているのに1ページあたり20件では少なすぎてイライラする（※個人の感想です）ので、設定で20件・50件・100件・制限なしの4つから選べるようにした。
            </p>

            <h4>遅延反映</h4>
            <p>
                テキストボックスに表示するためのStateと、検索に用いるためのStateを分け、前者を遅延させて後者に反映させることで無駄な検索処理が走らないようにした。具体的には以下の通り。
            </p>
            <LazySearch />

            <h3>レスポンシブデザイン</h3>
            <p>
                検索結果は<CodeInline>{"<table>"}</CodeInline>で返し、セマンティクスも意識して1つの任務を1つの
                <CodeInline>{"<tr>"}</CodeInline>
                で表していため、このままでは横幅の狭い端末で見るとはみ出してしまう。
                <br />
                本アプリはPCでの利用を想定しているものの、このご時世にスマホで見たら横にはみ出すのは流石にダサい。
                <br />
                よって一定の横幅以下の場合は<CodeInline>{"<tr>"}</CodeInline>
                にCSSグリッドレイアウトを適用し、1行で表示していたものを複数行に分けた。
                <br />
                ただし、1行で表示している場合と異なり列ヘッダを表示する必要があるため、カスタムデータ属性・before疑似要素・
                <CodeInline>attr</CodeInline>関数の組み合わせでなんとかする。
            </p>
            <ColumnHeader />
            <p>
                任務リストマネージャーはこの対応でどうにかなったが、遠征チェッカーで同じ手法を用いても良いデザインにならなかったためおとなしく
                <CodeInline>matchMedia</CodeInline>
                関数を用いてコンポーネント側で条件分岐させた。ただこの方法、管理コストが2倍になるのであまり使いたくない手段ではある…
            </p>

            <h3>マスターデータの用意</h3>
            <p>
                先述の通り非公式wikiをスクレイピングすることでマスターデータを作っているが、当然ながらwikiに書かれている内容は人間が読みやすいものであり、機械フレンドリーではない。
                さらにwikiはmarkdownのような言語をただHTMLに変換するだけなので、全くセマンティックなものにならない。例えば表中だと段落
                <CodeInline>{"<p>"}</CodeInline>などなく意味の切れ目を探し出すのに苦労した。
                <br />
                しかしそれは大した問題ではなく…
            </p>
            <p>
                艦これの装備は設定された数値分だけ装備した艦娘のステータスを上昇させるものだが、特定の艦娘に特定の装備を持たせたときのみ追加でステータスが上昇する組み合わせがある。しかも同種の装備を複数持たせた場合や、特定の装備の組み合わせがある場合はさらに追加で上昇するなどはっきり言って相当ややこしい。例えば以下。
            </p>
            <ul>
                <li>艦娘「深雪改二」に</li>
                <ul>
                    <li>
                        装備「12.7cm連装砲A型改二」を持たせると1つごとに火力+2
                        <ul>
                            <li>
                                「12.7cm連装砲A型改二」が10段階改修されていると↑に加えてさらに1つごとに火力+11, 命中+4
                            </li>
                            <li>2つ持たせるとさらに火力+2</li>
                            <li>3つ持たせるとさらに火力+3</li>
                        </ul>
                    </li>
                    <li>
                        装備「12.7cm連装砲A型改二」を1つ以上持たせた状態でさらに水上電探に分類される装備を持たせると火力+3,
                        雷装+1, 回避+2
                    </li>
                    <li>
                        装備「12.7cm連装砲A型改二」を1つ以上持たせた状態でさらに「61cm三連装魚雷」およびその上位互換の装備を持たせると火力+1,
                        雷装+3, 回避+2
                        <ul>
                            <li>この条件のもとで持たせる「61cm三連装魚雷」が2つ以上の場合はさらに火力+1, 雷装+2</li>
                            <li>持たせる魚雷が「61cm三連装(酸素)魚雷後期型」の場合はさらに一度だけ雷装+1</li>
                        </ul>
                    </li>
                </ul>
            </ul>
            <p>
                <s>ゲーム側のプログラムマジでどうなってんの…？</s>
            </p>
            <p>
                当然wikiにも装備ボーナスが書いてあるが、複数の装備の組み合わせによるボーナスの場合、まとめられた数値が記載される傾向にある。よって複数の装備の組み合わせによるボーナスが複数の存在するとき（上記例に沿って言えば深雪改二に「12.7cm連装砲A型改二」「61cm三連装(酸素)魚雷後期型」「22号対水上電探改四(後期調整型)」を持たせた場合）にボーナスを重複してカウントしてしまう可能性が非常に高い。
                <br />
                かといって記載されている数値がまとめられたものなのかどうかを機械的に判断するのは難しく、万事休す…。
                <br />
                と思いきや英語版非公式wikiだと逆に「その条件が追加されたときの増分のみ」が記載される傾向にあるようで、こちらをスクレイピングすることで事なきを得た。
                <br />
                （この部分だけ取り上げると、パッと見の情報量を取るのが日本語版wiki、情報の厳密性を取るのが英語版wikiとも言える。このあたりは文化の違いによるものなのだろうか…）
            </p>

            <h3>ヘルプページ</h3>
            <p>
                前提任務・後続任務など少々ややこしいところもあるので画像付きで説明を付けたいが、前述の通りレスポンシブデザインでデバイスの幅が広いときと狭いときの表示にそこそこ差がある。そのため、それだったらむしろ実際のコンポーネントを置いたほうがいいのではないかと考えた。
                <br />
                ただし本当にそのままコンポーネントを置くと保存データに影響を及ぼしてしまうので、コンテナ・プレゼンテーションパターンで関心の分離を行ったうえでモックを作成する。
                <br />
                具体的には検索結果の任務1つを表すコンポーネントを、プレゼンテーションのみを扱う
                <CodeInline>QuestTableRow</CodeInline>とロジック部分を扱うカスタムフック
                <CodeInline>useQuestTableRow</CodeInline>に分け、ヘルプページでは<CodeInline>QuestTableRow</CodeInline>
                を包含してモックを作った。
                <br />
                これによりレスポンシブデザインを反映できるだけではなく、実際に操作してどうなるかが確認できるサンプルが表示されることになるため、ユーザビリティを高めることにもなった。
                <br />
                （実際にどのくらいのユーザーがヘルプページをきちんと読むかどうかという問題はあるが…）
            </p>

            <h3>テスタビリティの確保</h3>
            <p>
                上でもちらっと述べたが、ほとんどのコンポーネントにおいてコンテナ・プレゼンテーションパターンで関心の分離を行うことにより、テスタビリティを確保することを意識した。これにより任務データをモックデータとして与えることで多少込み入った検索や「前提任務をすべて達成済にする」ボタンなどの挙動のテストがかなり楽に行えるようになった。
            </p>

            <h3>テスト</h3>
            <h4>Recoil Atomのオブザーバー</h4>
            <p>
                Atomの値の変化を見たいときは Recoil公式ドキュメントの
                <ExternalLink href="https://recoiljs.org/docs/guides/testing">Testing</ExternalLink>ページに書いてある
                <CodeInline>RecoilObserver</CodeInline>
                を実装して使えばOK。これは本当に便利。
            </p>

            <h4>Recoil Atom, Selectorのモック</h4>
            <p>
                <ExternalLink href="https://zenn.dev/babel/articles/recoil-for-babel">
                    Recoilにロジックを載せる運用戦略
                </ExternalLink>
                内に記載のあった<ExternalLink href="https://github.com/babel-jp/recoil-mock">recoil-mock</ExternalLink>
                を使っている。
                <br />
                ただしrecoil-mockでモックするとrecoil-mockのメソッドのみでしかAtomが書き換わらないため、Atomの値に応じて挙動が変化するようなカスタムフックのテストができない。よってこの場合は単に
                <CodeInline>useEffect</CodeInline>
                で初期値を設定するという力業で対応した。今のところは問題ないようである。
            </p>
        </article>
    );
};

export default KanColleQuestManager;
